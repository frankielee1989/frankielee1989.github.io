<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>合并两个有序数组</title>
    <link href="/2020/06/30/merge-sorted-array/"/>
    <url>/2020/06/30/merge-sorted-array/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><p>给你两个有序整数数组 <em>nums1</em> 和 <em>nums2</em> ，请你将 <em>nums2</em> 合并到 <em>nums1</em> 中<em>，</em>使 <em>nums1</em> 成为一个有序数组。</p><p><strong>说明：</strong></p><ul><li>初始化 <em>nums1</em> 和 <em>nums2</em> 的元素数量分别为 <em>m</em> 和 <em>n</em>。</li><li>你可以假设 <em>nums1</em> 有足够的空间（空间大小大于或等于 <em>m</em> + <em>n</em>）来保存 <em>nums2</em> 中的元素。</li></ul><p><strong>示例：</strong></p><pre><code class="hljs angelscript">输入:nums1 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>], m = <span class="hljs-number">3</span>nums2 = [<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>],       n = <span class="hljs-number">3</span>输出: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]</code></pre><p><strong>解题思路：</strong></p><ul><li>标签：从后向前数组遍历</li><li>因为 <code>nums1</code> 的空间都集中在后面，所以从后向前处理排序的数据会更好，节省空间，一边遍历一边将值填充进去</li><li>设置指针 len1 和 len2 分别指向 nums1 和 nums2 的有数字尾部，从尾部值开始比较遍历，同时设置指针 len 指向 nums1 的最末尾，每次遍历比较值大小之后，则进行填充</li><li>当 <code>len1&lt;0</code> 时遍历结束，此时 <code>nums2</code> 中还有数据未拷贝完全，将其直接拷贝到 <code>nums1</code> 的前面，最后得到结果数组</li><li>时间复杂度：O(m+n)</li></ul><p><strong>图解：</strong></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggae3qeas6j30zk0ivt9j.jpg" srcset="/img/loading.gif" alt="img"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggae4017rlj30zk0ivdgn.jpg" srcset="/img/loading.gif" alt="img"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggae496f97j30zk0ivmxy.jpg" srcset="/img/loading.gif" alt="img"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggae4h2iy0j30zk0ivmy0.jpg" srcset="/img/loading.gif" alt="img"></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span>[] nums2, <span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">int</span> len1 = m - <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> len2 = n - <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> len = m + n - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(len1 &gt;= <span class="hljs-number">0</span> &amp;&amp; len2 &gt;= <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">// 注意--符号在后面，表示先进行计算再减1，这种缩写缩短了代码</span>            nums1[len--] = nums1[len1] &gt; nums2[len2] ? nums1[len1--] : nums2[len2--];        &#125;        <span class="hljs-comment">// 表示将nums2数组从下标0位置开始，拷贝到nums1数组中，从下标0位置开始，长度为len2+1</span>        System.arraycopy(nums2, <span class="hljs-number">0</span>, nums1, <span class="hljs-number">0</span>, len2 + <span class="hljs-number">1</span>);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>隐秘的角落让我印象深刻的镜头</title>
    <link href="/2020/06/29/thebadkids/"/>
    <url>/2020/06/29/thebadkids/</url>
    
    <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg9g4gei65j31hc0u014d.jpg" srcset="/img/loading.gif" alt="p2611236839"></p><p>最明亮清新的画面，最暗潮汹涌的同框。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg9eg5ca8oj31hc0u0npf.jpg" srcset="/img/loading.gif" alt="p2609494086.jpg"></p><p>这是全剧唯一一个能让人看到他们身上依然保有童真的镜头。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg9g5o71b4j311y0lbn6d.jpg" srcset="/img/loading.gif" alt="p2609823056.jpg"></p><p>甜腻又恶心。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg9g62u474j31hc0swtjg.jpg" srcset="/img/loading.gif" alt="p2610642764"></p><p>另一种授课，黑化的开始。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg9g7hjoqzj31hc0sw77f.jpg" srcset="/img/loading.gif" alt="p2611410903"></p><p>以爱之名行恶，最终失去所爱。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg9g805k66j31hc0swn4z.jpg" srcset="/img/loading.gif" alt="p2611413427"></p><p>朝阳，东升。</p>]]></content>
    
    
    <categories>
      
      <category>movies</category>
      
    </categories>
    
    
    <tags>
      
      <tag>国产剧</tag>
      
      <tag>好剧</tag>
      
      <tag>隐秘的角落</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>稀疏数组</title>
    <link href="/2020/06/29/SparseArray/"/>
    <url>/2020/06/29/SparseArray/</url>
    
    <content type="html"><![CDATA[<h2 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h3><p>​    稀疏数组可以看做是普通数组的压缩，但是这里说的普通数组是值无效数据量远大于有效数据量的数组</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg8uuowb2jj30se0is41t.jpg" srcset="/img/loading.gif" alt="img"></p><h3 id="2-存储"><a href="#2-存储" class="headerlink" title="2. 存储"></a>2. 存储</h3><p>​    刚说到稀疏数组是一种压缩后的数组，为什么要进行压缩存储呢？</p><ul><li>原数组中存在大量的无效数据，占据了大量的存储空间，真正有用的数据却少之又少</li><li>压缩存储可以节省存储空间以避免资源的不必要的浪费，在数据序列化到磁盘时，压缩存储可以提高IO效率</li></ul><h3 id="3-存储方式"><a href="#3-存储方式" class="headerlink" title="3. 存储方式"></a>3. 存储方式</h3><p>​         第一行存储原始数据总行数，总列数，总的非0数据个数</p><p>​         接下来每一行都存储非0数所在行，所在列，和具体值</p><h3 id="4-代码实现"><a href="#4-代码实现" class="headerlink" title="4. 代码实现"></a>4. 代码实现</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SparseArray</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * &lt;p&gt;</span><span class="hljs-comment">     *     稀疏数组可以简单的看作为是压缩，在开发中也会使用到。比如将数据序列化到磁盘上，减少数据量，在IO过程中提高效率等等。</span><span class="hljs-comment">     *</span><span class="hljs-comment">     *     &lt;p&gt;</span><span class="hljs-comment">     *         为什么要进行压缩？</span><span class="hljs-comment">     *              - 由于稀疏矩阵中存在大量的“空”值，占据了大量的存储空间，而真正有用的数据却少之又少，</span><span class="hljs-comment">     *              - 且在计算时浪费资源，所以要进行压缩存储以节省存储空间和计算方便。</span><span class="hljs-comment">     *     &lt;/p&gt;</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * &lt;/p&gt;</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> args</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 初始化二维数组</span><span class="hljs-comment">         * &lt;p&gt;</span><span class="hljs-comment">         *     0 0 0 0 0 0 0 0 0 0 0</span><span class="hljs-comment">         *     0 0 1 0 0 0 0 0 0 0 0</span><span class="hljs-comment">         *     0 0 0 0 2 0 0 0 0 0 0</span><span class="hljs-comment">         *     0 0 0 0 0 0 0 0 0 0 0</span><span class="hljs-comment">         *     0 0 0 0 0 0 0 0 0 0 0</span><span class="hljs-comment">         *     0 0 0 0 0 0 0 0 0 0 0</span><span class="hljs-comment">         *     0 0 0 0 0 0 0 0 0 0 0</span><span class="hljs-comment">         *     0 0 0 0 0 0 0 0 0 0 0</span><span class="hljs-comment">         *     0 0 0 0 0 0 0 0 0 0 0</span><span class="hljs-comment">         *     0 0 0 0 0 0 0 0 0 0 0</span><span class="hljs-comment">         *     0 0 0 0 0 0 0 0 0 0 0</span><span class="hljs-comment">         * &lt;/p&gt;</span><span class="hljs-comment">         */</span>        <span class="hljs-comment">//初始化原数组</span>        <span class="hljs-keyword">int</span>[][] array = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">11</span>][<span class="hljs-number">11</span>];        array[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;        array[<span class="hljs-number">2</span>][<span class="hljs-number">4</span>] = <span class="hljs-number">2</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>[] row : array)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> item : row)&#123;                System.out.printf(<span class="hljs-string">"%d\t"</span>,item);            &#125;        &#125;        System.out.println(<span class="hljs-string">"---------&gt; 二维数组转稀疏数组"</span>);        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 稀疏数组</span><span class="hljs-comment">         * &lt;p&gt;</span><span class="hljs-comment">         *     11 11 2</span><span class="hljs-comment">         *     1  2  1</span><span class="hljs-comment">         *     2  4  2</span><span class="hljs-comment">         * &lt;/p&gt;</span><span class="hljs-comment">         */</span>        <span class="hljs-comment">//得到非0数据数</span>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;<span class="hljs-number">11</span>;i++)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j&lt;<span class="hljs-number">11</span>;j++)&#123;                <span class="hljs-keyword">if</span>(array[i][j] != <span class="hljs-number">0</span>)&#123;                    sum++;                &#125;            &#125;        &#125;        <span class="hljs-comment">//创建稀疏数组</span>        <span class="hljs-keyword">int</span>[][] sparseArray = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[sum+<span class="hljs-number">1</span>][<span class="hljs-number">3</span>];        <span class="hljs-comment">//给稀疏数组赋值</span>        sparseArray[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">11</span>;        sparseArray[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">11</span>;        sparseArray[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] = sum;        <span class="hljs-comment">//将非0的数放入稀疏数组</span>        <span class="hljs-comment">//count：标识第几个非0数</span>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;<span class="hljs-number">11</span>;i++)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j&lt;<span class="hljs-number">11</span>;j++)&#123;                <span class="hljs-keyword">if</span>(array[i][j] != <span class="hljs-number">0</span>)&#123;                    count++;                    sparseArray[count][<span class="hljs-number">0</span>] = i;                    sparseArray[count][<span class="hljs-number">1</span>] = j;                    sparseArray[count][<span class="hljs-number">2</span>] = array[i][j];                &#125;            &#125;        &#125;        <span class="hljs-comment">//遍历稀疏数组</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;sparseArray.length;i++)&#123;            System.out.printf(<span class="hljs-string">"%d%d%d\t"</span>,sparseArray[i][<span class="hljs-number">0</span>],sparseArray[i][<span class="hljs-number">1</span>],sparseArray[i][<span class="hljs-number">2</span>]);        &#125;        System.out.println(<span class="hljs-string">"-----------&gt;稀疏数组转回原始数组"</span>);        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 恢复的二维数组</span><span class="hljs-comment">         * &lt;p&gt;</span><span class="hljs-comment">         *     0 0 0 0 0 0 0 0 0 0 0</span><span class="hljs-comment">         *     0 0 1 0 0 0 0 0 0 0 0</span><span class="hljs-comment">         *     0 0 0 0 2 0 0 0 0 0 0</span><span class="hljs-comment">         *     0 0 0 0 0 0 0 0 0 0 0</span><span class="hljs-comment">         *     0 0 0 0 0 0 0 0 0 0 0</span><span class="hljs-comment">         *     0 0 0 0 0 0 0 0 0 0 0</span><span class="hljs-comment">         *     0 0 0 0 0 0 0 0 0 0 0</span><span class="hljs-comment">         *     0 0 0 0 0 0 0 0 0 0 0</span><span class="hljs-comment">         *     0 0 0 0 0 0 0 0 0 0 0</span><span class="hljs-comment">         *     0 0 0 0 0 0 0 0 0 0 0</span><span class="hljs-comment">         *     0 0 0 0 0 0 0 0 0 0 0</span><span class="hljs-comment">         * &lt;/p&gt;</span><span class="hljs-comment">         */</span>        <span class="hljs-keyword">int</span>[][] oldArray = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[sparseArray[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]][sparseArray[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]];        <span class="hljs-comment">//将原来非0的数填充回去</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i&lt;=count;i++)&#123;          oldArray[sparseArray[i][<span class="hljs-number">0</span>]][sparseArray[i][<span class="hljs-number">1</span>]] = sparseArray[i][<span class="hljs-number">2</span>];        &#125;        <span class="hljs-comment">//遍历刚转回的原始数组</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>[] row : oldArray)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> item : row)&#123;                System.out.printf(<span class="hljs-string">"%d\t"</span>,item);            &#125;        &#125;    &#125;&#125;</code></pre><h3 id="将稀疏存储到磁盘中"><a href="#将稀疏存储到磁盘中" class="headerlink" title="将稀疏存储到磁盘中"></a>将稀疏存储到磁盘中</h3><p>我们可以使用java的IO流将稀疏数组存放到磁盘中，原数组和稀疏数组比较，肯定是稀疏数组体积更小，占用空间更小</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 将稀疏数组存入磁盘（文件）</span><span class="hljs-comment"> *</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sparseArrayToIo</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] sparseArray)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;  File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">"sparseArray.txt"</span>);  <span class="hljs-keyword">if</span>(!file.exists())&#123;    file.createNewFile();  &#125;  FileWriter writer = <span class="hljs-keyword">new</span> FileWriter(file);  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>; i &lt; sparseArray.length; i++) &#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++) &#123;      writer.write(sparseArray[i][j]);    &#125;  &#125;  writer.flush();  writer.close();&#125;</code></pre><h3 id="从磁盘中读取稀疏数组"><a href="#从磁盘中读取稀疏数组" class="headerlink" title="从磁盘中读取稀疏数组"></a>从磁盘中读取稀疏数组</h3><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 读文件获取稀疏数组</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[][] sparseArrayFromIo() <span class="hljs-keyword">throws</span> Exception &#123;  Map&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap();  <span class="hljs-keyword">int</span> count=<span class="hljs-number">0</span>; <span class="hljs-keyword">int</span> data = <span class="hljs-number">0</span>;  <span class="hljs-keyword">while</span> ((data=reader.read())!=-<span class="hljs-number">1</span>)&#123;    map.put(count,data); count++;  &#125;  <span class="hljs-keyword">if</span> (map.size() == <span class="hljs-number">0</span>)&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;  &#125;  <span class="hljs-keyword">int</span>[][] sparseArray = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[map.size()/<span class="hljs-number">3</span>][<span class="hljs-number">3</span>];  <span class="hljs-keyword">int</span> index =<span class="hljs-number">0</span>;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; map.size()/<span class="hljs-number">3</span>; i++) &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++) &#123;      sparseArray[i][j] = map.get(index);      index ++;    &#125;  &#125;  map.clear();  <span class="hljs-keyword">return</span> sparseArray;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回文数</title>
    <link href="/2020/06/28/palindrome-number/"/>
    <url>/2020/06/28/palindrome-number/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p><p><strong>示例：</strong></p><pre><code class="hljs yaml"><span class="hljs-string">输入:</span> <span class="hljs-number">121</span><span class="hljs-string">输出:</span> <span class="hljs-literal">true</span><span class="hljs-string">输入:</span> <span class="hljs-number">-121</span><span class="hljs-string">输出:</span> <span class="hljs-literal">false</span><span class="hljs-string">解释:</span> <span class="hljs-string">从左向右读,</span> <span class="hljs-string">为</span> <span class="hljs-number">-121</span> <span class="hljs-string">。</span> <span class="hljs-string">从右向左读,</span> <span class="hljs-string">为</span> <span class="hljs-number">121</span><span class="hljs-bullet">-</span> <span class="hljs-string">。因此它不是一个回文数。</span><span class="hljs-string">输入:</span> <span class="hljs-number">10</span><span class="hljs-string">输出:</span> <span class="hljs-literal">false</span><span class="hljs-string">解释:</span> <span class="hljs-string">从右向左读,</span> <span class="hljs-string">为</span> <span class="hljs-number">01</span> <span class="hljs-string">。因此它不是一个回文数。</span></code></pre><p><strong>进阶：</strong></p><p>你能不将整数转为字符串来解决这个问题吗？</p><p><strong>解题思路：</strong></p><p>直观上来看待回文数的话，就感觉像是将数字进行对折后看能否一一对应。</p><p>所以这个解法的操作就是 <strong>取出后半段数字进行翻转</strong>。</p><p>这里需要注意的一个点就是由于回文数的位数可奇可偶，所以当它的长度是偶数时，它对折过来应该是相等的；当它的长度是奇数时，那么它对折过来后，有一个的长度需要去掉一位数（除以 10 并取整）。</p><p>具体做法如下：</p><ul><li>每次进行取余操作 （ %10），取出最低的数字：<code>y = x % 10</code></li><li>将最低的数字加到取出数的末尾：<code>revertNum = revertNum * 10 + y</code></li><li>每取一个最低位数字，x 都要自除以 10</li><li>判断 <code>x</code> 是不是小于 <code>revertNum</code> ，当它小于的时候，说明数字已经对半或者过半了</li><li>最后，判断奇偶数情况：如果是偶数的话，revertNum 和 x 相等；如果是奇数的话，最中间的数字就在revertNum 的最低位上，将它除以 10 以后应该和 x 相等。</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg89t68nt2j31800u0wku.jpg" srcset="/img/loading.gif" alt="img"></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;        <span class="hljs-comment">//思考：这里大家可以思考一下，为什么末尾为 0 就可以直接返回 false</span>        <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || (x % <span class="hljs-number">10</span> == <span class="hljs-number">0</span> &amp;&amp; x != <span class="hljs-number">0</span>)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">int</span> revertedNumber = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (x &gt; revertedNumber) &#123;            revertedNumber = revertedNumber * <span class="hljs-number">10</span> + x % <span class="hljs-number">10</span>;            x /= <span class="hljs-number">10</span>;        &#125;        <span class="hljs-keyword">return</span> x == revertedNumber || x == revertedNumber / <span class="hljs-number">10</span>;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>整数反转</title>
    <link href="/2020/06/28/reverse-integer/"/>
    <url>/2020/06/28/reverse-integer/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p><p><strong>示例：</strong></p><pre><code class="hljs angelscript">输入: <span class="hljs-number">123</span>输出: <span class="hljs-number">321</span>输入: <span class="hljs-number">-123</span>输出: <span class="hljs-number">-321</span>输入: <span class="hljs-number">120</span>输出: <span class="hljs-number">21</span></code></pre><p><strong>注意：</strong></p><p>假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [-2147483647, 2147483647]。请根据这个假设，如果反转后整数溢出那么就返回 0。</p><p><strong>解题思路：</strong></p><p>依次取出当前数字的最后一位数，累加。<br>关键在于如何判断整数溢出：将每次操作后的数字用临时变量存储，对该变量“反操作”，若与操作前的结果不等，则发生溢出，直接返回0</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span> ;        <span class="hljs-keyword">while</span>(x != <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">int</span> temp = x % <span class="hljs-number">10</span> + res * <span class="hljs-number">10</span>;            <span class="hljs-keyword">if</span>((temp - x % <span class="hljs-number">10</span>) / <span class="hljs-number">10</span> != res)&#123; <span class="hljs-comment">//最关键的一步</span>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> ;            &#125;            res = temp ;            x /= <span class="hljs-number">10</span> ;        &#125;        <span class="hljs-keyword">return</span> res ;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>验证回文字符串 Ⅱ</title>
    <link href="/2020/06/28/valid-palindrome-ii/"/>
    <url>/2020/06/28/valid-palindrome-ii/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong><br>给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。</p><p><strong>示例：</strong><br>输入: “aba”<br>输出: True</p><p>输入: “abca”<br>输出: True<br>解释: 你可以删除c字符。</p><p><strong>解题思路：</strong><br>使用双指针可以很容易判断一个字符串是否是回文字符串：令一个指针从左到右遍历，一个指针从右到左遍历，这两个指针同时移动一个位置，每次都判断两个指针指向的字符是否相同，如果都相同，字符串才是具有左右对称性质的回文字符串。<br>                                     <img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg890ifl4qg309v08rglm.gif" srcset="/img/loading.gif" alt=""><br>本题的关键是处理删除一个字符。在使用双指针遍历字符串时，如果出现两个指针指向的字符不相等的情况，我们就试着删除一个字符，再判断删除完之后的字符串是否是回文字符串。<br>在判断是否为回文字符串时，我们不需要判断整个字符串，因为左指针左边和右指针右边的字符之前已经判断过具有对称性质，所以只需要判断中间的子字符串即可。<br>在试着删除字符时，我们既可以删除左指针指向的字符，也可以删除右指针指向的字符。<br>                                <img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg890hr41tg30ce08dt8y.gif" srcset="/img/loading.gif" alt=""></p><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">validPalindrome</span><span class="hljs-params">(String s)</span> </span>&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = s.length() - <span class="hljs-number">1</span>; i &lt; j; i++, j--) &#123;            <span class="hljs-keyword">if</span>(s.charAt(i) != s.charAt(j)) &#123;                <span class="hljs-keyword">return</span> isPalindrome(s, i + <span class="hljs-number">1</span>, j) || isPalindrome(s, i, j - <span class="hljs-number">1</span>);            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;        <span class="hljs-keyword">while</span>(i &lt; j) &#123;            <span class="hljs-keyword">if</span>(s.charAt(i++) != s.charAt(j--)) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>反转字符串中的元音字母</title>
    <link href="/2020/06/28/reverse-vowels-of-a-string/"/>
    <url>/2020/06/28/reverse-vowels-of-a-string/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong><br>编写一个函数，以字符串作为输入，反转该字符串中的元音字母。</p><p><strong>示例：</strong><br>输入: “hello”<br>输出: “holle”</p><p>输入: “leetcode”<br>输出: “leotcede”</p><p><strong>解题思路：</strong><br>使用双指针，一个指针从头向尾遍历，一个指针从尾到头遍历，当两个指针都遍历到元音字符时，交换这两个元音字符。<br>为了快速判断一个字符是不是元音字符，我们将全部元音字符添加到集合 HashSet 中，从而以 O(1) 的时间复杂度进行该操作。</p><ul><li>时间复杂度为 O(N)：只需要遍历所有元素一次</li><li>空间复杂度 O(1)：只需要使用两个额外变量</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg88we5abcg30jc0btaan.gif" srcset="/img/loading.gif" alt=""></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> HashSet&lt;Character&gt; vowels =  <span class="hljs-keyword">new</span> HashSet&lt;&gt;(        Arrays.asList(<span class="hljs-string">'a'</span>, <span class="hljs-string">'e'</span>, <span class="hljs-string">'i'</span>, <span class="hljs-string">'o'</span>, <span class="hljs-string">'u'</span>, <span class="hljs-string">'A'</span>, <span class="hljs-string">'E'</span>, <span class="hljs-string">'I'</span>, <span class="hljs-string">'O'</span>, <span class="hljs-string">'U'</span>));    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">reverseVowels</span><span class="hljs-params">(String s)</span> </span>&#123;        <span class="hljs-keyword">if</span>(s == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = s.length() - <span class="hljs-number">1</span>;        <span class="hljs-keyword">char</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[s.length()];        <span class="hljs-keyword">while</span>(i &lt;= j) &#123;            <span class="hljs-keyword">char</span> ci = s.charAt(i);            <span class="hljs-keyword">char</span> cj = s.charAt(j);            <span class="hljs-keyword">if</span>(!vowels.contains(ci)) &#123;                result[i++] = ci;            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!vowels.contains(cj)) &#123;                result[j--] = cj;            &#125;<span class="hljs-keyword">else</span> &#123;                result[i++] = cj;                result[j--] = ci;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(result);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>平方数之和</title>
    <link href="/2020/06/28/sum-of-square-numbers/"/>
    <url>/2020/06/28/sum-of-square-numbers/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong><br>给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a&sup2; + b&sup2; = c。</p><p><strong>示例：</strong></p><pre><code class="hljs yaml"><span class="hljs-string">输入:</span> <span class="hljs-number">5</span><span class="hljs-string">输出:</span> <span class="hljs-literal">True</span><span class="hljs-string">解释:</span> <span class="hljs-number">1</span> <span class="hljs-string">*</span> <span class="hljs-number">1</span> <span class="hljs-string">+</span> <span class="hljs-number">2</span> <span class="hljs-string">*</span> <span class="hljs-number">2</span> <span class="hljs-string">=</span> <span class="hljs-number">5</span></code></pre><pre><code class="hljs yaml"><span class="hljs-string">输入:</span> <span class="hljs-number">3</span><span class="hljs-string">输出:</span> <span class="hljs-literal">False</span></code></pre><p><strong>解题思路：</strong><br>可以看成是在元素为 0 ~ target 的有序数组中查找两个数，使得这两个数的平方和为 target，如果能找到，则返回 true，表示 target 是两个整数的平方和。<br>本题和 167. Two Sum II - Input array is sorted 类似，只有一个明显区别：一个是和为 target，一个是平方和为 target。本题同样可以使用双指针得到两个数，使其平方和为 target。<br>本题的关键是右指针的初始化，实现剪枝，从而降低时间复杂度。设右指针为 x，左指针固定为 0，为了使 0&sup2; + x&sup2; 的值尽可能接近 target，我们可以将 x 取为 sqrt(target)。<br>因为最多只需要遍历一次 0 ~ sqrt(target)，所以时间复杂度为 O(sqrt(target))。又因为只使用了两个额外的变量，因此空间复杂度为 O(1)。</p><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">judgeSquareSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> target)</span> </span>&#123;        <span class="hljs-keyword">if</span>(target &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = (<span class="hljs-keyword">int</span>)Math.sqrt(target);        <span class="hljs-keyword">while</span>(i &lt;= j) &#123;            <span class="hljs-keyword">int</span> sum = i * i + j * j;            <span class="hljs-keyword">if</span>(sum == target) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum &gt; target) &#123;                j--;            &#125;<span class="hljs-keyword">else</span> &#123;                i++;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>两数之和</title>
    <link href="/2020/06/28/twosum/"/>
    <url>/2020/06/28/twosum/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong><br>    给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。<br>    你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。<br><strong>示例：</strong><br>    给定 nums = [2, 7, 11, 15], target = 9<br>    因为 nums[0] + nums[1] = 2 + 7 = 9<br>    所以返回 [0, 1]<br><strong>解题思路：</strong></p><ul><li><p>标签：哈希映射</p></li><li><p>这道题本身如果通过暴力遍历的话也是很容易解决的，时间复杂度在 O(n2)</p></li><li><p>由于哈希查找的时间复杂度为 O(1)，所以可以利用哈希容器 map 降低时间复杂度</p></li><li><p>遍历数组 nums，i 为当前下标，每个值都判断map中是否存在 target-nums[i] 的 key 值</p></li><li><p>如果存在则找到了两个值，如果不存在则将当前的 (nums[i],i) 存入 map 中，继续遍历直到找到为止</p></li><li><p>如果最终都没有结果则抛出异常</p></li><li><p>时间复杂度：O(n)</p></li></ul><p>  <strong>图解：</strong></p><p>  <img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg87mvg7buj30yo0k2758.jpg" srcset="/img/loading.gif" alt="1"></p><p>  <img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg87n0zbh3j30yo0k2q4a.jpg" srcset="/img/loading.gif" alt="2"></p><p>  <img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg87n55x68j30yo0k2abf.jpg" srcset="/img/loading.gif" alt="3"></p><p>  <img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg87nd6l3bj30yo0k2tab.jpg" srcset="/img/loading.gif" alt="4"></p><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] twoSum(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt; nums.length; i++) &#123;            <span class="hljs-keyword">int</span> complement = target - nums[i];            <span class="hljs-keyword">if</span>(map.containsKey(complement)) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123;map.get(complement),i&#125;;            &#125;            map.put(nums[i], i);        &#125;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"No two sum solution"</span>);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
