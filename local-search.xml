<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>26.删除排序数组中的重复项</title>
    <link href="/2020/07/02/RemoveDuplicates/"/>
    <url>/2020/07/02/RemoveDuplicates/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p><p><strong>示例1：</strong></p><pre><code class="hljs angelscript">给定数组 nums = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], 函数应该返回新的长度 <span class="hljs-number">2</span>, 并且原数组 nums 的前两个元素被修改为 <span class="hljs-number">1</span>, <span class="hljs-number">2</span>。 你不需要考虑数组中超出新长度后面的元素。</code></pre><p><strong>示例2：</strong></p><pre><code class="hljs angelscript">给定 nums = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],函数应该返回新的长度 <span class="hljs-number">5</span>, 并且原数组 nums 的前五个元素被修改为 <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>。你不需要考虑数组中超出新长度后面的元素。</code></pre><p><strong>说明：</strong></p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><pre><code class="hljs go"><span class="hljs-comment">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span><span class="hljs-keyword">int</span> <span class="hljs-built_in">len</span> = removeDuplicates(nums);<span class="hljs-comment">// 在函数里修改输入数组对于调用者是可见的。</span><span class="hljs-comment">// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>; i++) &#123;    <span class="hljs-built_in">print</span>(nums[i]);&#125;</code></pre><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>首先注意数组是有序的，那么重复的元素一定会相邻。</p><p>要求删除重复元素，实际上就是将不重复的元素移到数组的左侧。</p><p>考虑用 2 个指针，一个在前记作 <code>p</code>，一个在后记作 <code>q</code>，算法流程如下：</p><p>比较 <code>p</code> 和 <code>q</code> 位置的元素是否相等</p><ul><li>如果相等，<code>q</code> 后移 1 位</li><li>如果不相等，将 <code>q</code> 位置的元素复制到 <code>p+1</code> 位置上，<code>p</code> 后移一位，<code>q</code> 后移 1 位<br>重复上述过程，直到 <code>q</code> 等于数组长度。</li><li>返回 <code>p + 1</code>，即为新数组长度。</li></ul><p><strong>图解：</strong></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggcq4gsyepj30fk0rb0tj.jpg" srcset="/img/loading.gif" alt="1.png"></p><p><strong>优化：</strong></p><p>这是大部分题解都没有提出的，在这里提一下。</p><p>考虑如下数组：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggcq52x2cgj3098054743.jpg" srcset="/img/loading.gif" alt="2.png"></p><p>此时数组中没有重复元素，按照上面的方法，每次比较时 nums[p] 都不等于 nums[q]，因此就会将 q 指向的元素原地复制一遍，这个操作其实是不必要的。</p><p>因此我们可以添加一个小判断，当 q - p &gt; 1 时，才进行复制。</p><p><strong>复杂度分析：</strong></p><p>时间复杂度：O(n) 。<br>空间复杂度：O(1) 。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">if</span>(nums == <span class="hljs-keyword">null</span> || nums.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> q = <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span>(q &lt; nums.length)&#123;        <span class="hljs-keyword">if</span>(nums[p] != nums[q])&#123;            <span class="hljs-keyword">if</span>(q - p &gt; <span class="hljs-number">1</span>)&#123;                nums[p + <span class="hljs-number">1</span>] = nums[q];            &#125;            p++;        &#125;        q++;    &#125;    <span class="hljs-keyword">return</span> p + <span class="hljs-number">1</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>双指针</tag>
      
      <tag>简单</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 53 - II. 0～n-1中缺失的数字</title>
    <link href="/2020/07/02/MissingNumber/"/>
    <url>/2020/07/02/MissingNumber/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p><p><strong>示例1：</strong></p><pre><code class="hljs angelscript">输入: [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>]输出: <span class="hljs-number">2</span></code></pre><p><strong>示例2：</strong></p><pre><code class="hljs angelscript">输入: [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>]输出: <span class="hljs-number">8</span></code></pre><p><strong>限制：</strong></p><p>1 &lt;= 数组长度 &lt;= 10000</p><h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><ul><li><p>排序数组中的搜索问题，首先想到 <strong>二分法</strong> 解决。</p></li><li><p>根据题意，数组可以按照以下规则划分为两部分。</p><ul><li><strong>左子数组：</strong> nums[i]=i ；</li><li><strong>右子数组：</strong> nums[i]≠i ；</li></ul></li><li><p>缺失的数字等于 <strong>“右子数组的首位元素”</strong> 对应的索引；因此考虑使用二分法查找 “右子数组的首位元素” 。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggcmvran5fj30q30jlgmi.jpg" srcset="/img/loading.gif" alt="Picture1.png"></p></li></ul><p><strong>算法解析：</strong></p><ol><li><strong>初始化：</strong> 左边界 i=0 ，右边界 j=len(nums)−1 ；代表闭区间 [i,j] 。</li><li><strong>循环二分：</strong> 当 i ≤ j 时循环（即当闭区间 [i, j] 为空时跳出）；<ul><li>计算中点 m=(i+j)//2 ，其中 “//“ 为向下取整除法；</li><li>若 nums[m]=m ，则 “右子数组的首位元素” 一定在闭区间 [m+1,j] 中，因此执行 i=m+1 ；</li><li>若 nums[m]≠m ，则 “左子数组的末位元素” 一定在闭区间 [i,m−1] 中，因此执行 j=m−1 ；</li></ul></li><li><strong>返回值：</strong> 跳出时，变量 i 和 j 分别指向 “右子数组的首位元素” 和 “左子数组的末位元素” 。因此返回 i 即可。</li></ol><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggcn000zfnj30uk0kbaa3.jpg" srcset="/img/loading.gif" alt="img"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggcn06jpkrj30uk0kbq32.jpg" srcset="/img/loading.gif" alt="img"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggcn0d27wwj30uk0kbq32.jpg" srcset="/img/loading.gif" alt="img"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggcn0j5n1xj30uk0kbq32.jpg" srcset="/img/loading.gif" alt="img"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggcn0orftdj30uk0kbq32.jpg" srcset="/img/loading.gif" alt="img"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggcn0unikaj30uk0kbwem.jpg" srcset="/img/loading.gif" alt="img"></p><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(logN) ：二分法为对数级别复杂度。</li><li>空间复杂度 O(1) ：几个变量使用常数大小的额外空间。</li></ul><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">missingNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = nums.length - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(i &lt;= j) &#123;            <span class="hljs-keyword">int</span> m = (i + j) / <span class="hljs-number">2</span>;            <span class="hljs-keyword">if</span>(nums[m] == m) i = m + <span class="hljs-number">1</span>;            <span class="hljs-keyword">else</span> j = m - <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">return</span> i;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>简单</tag>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1051.高度检查器</title>
    <link href="/2020/07/02/height-checker/"/>
    <url>/2020/07/02/height-checker/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>学校在拍年度纪念照时，一般要求学生按照 非递减 的高度顺序排列。</p><p>请你返回能让所有学生以 非递减 高度排列的最小必要移动人数。</p><p>注意，当一组学生被选中时，他们之间可以以任何可能的方式重新排序，而未被选中的学生应该保持不动。</p><pre><code class="hljs angelscript">输入：heights = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>]输出：<span class="hljs-number">3</span> 解释：当前数组：[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>]目标数组：[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]在下标 <span class="hljs-number">2</span> 处（从 <span class="hljs-number">0</span> 开始计数）出现 <span class="hljs-number">4</span> vs <span class="hljs-number">1</span> ，所以我们必须移动这名学生。在下标 <span class="hljs-number">4</span> 处（从 <span class="hljs-number">0</span> 开始计数）出现 <span class="hljs-number">1</span> vs <span class="hljs-number">3</span> ，所以我们必须移动这名学生。在下标 <span class="hljs-number">5</span> 处（从 <span class="hljs-number">0</span> 开始计数）出现 <span class="hljs-number">3</span> vs <span class="hljs-number">4</span> ，所以我们必须移动这名学生。输入：heights = [<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]输出：<span class="hljs-number">5</span>输入：heights = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]输出：<span class="hljs-number">0</span></code></pre><p><strong>提示：</strong></p><ol><li>1 &lt;= heights.length &lt;= 100</li><li>1 &lt;= heights[i] &lt;= 100</li></ol><h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p><strong>分析：</strong></p><p>非递减 排序也就是升序排列，最直观的一种解法就是排序后对比计数每个位置的不同数量。<br>但是涉及到比较排序，时间复杂度最低也有 O(N<em>log</em>N)。</p><p><strong>我们真的需要排序吗？</strong></p><p>首先我们其实并不关心排序后得到的结果，我们想知道的只是在该位置上，与最小的值是否一致<br>题目中已经明确了值的范围 1 &lt;= heights[i] &lt;= 100</p><p>这是一个在固定范围内的输入，比如输入： [1,1,4,2,1,3]</p><p>输入中有 3 个 <code>1</code>,1 个 <code>2</code>，1 个 <code>3</code> 和 1 个 <code>4</code>，3 个 <code>1</code> 肯定会在前面，依次类推<br>所以，我们需要的仅仅只是计数而已。</p><p><strong>复杂度分析：</strong></p><p>时间复杂度：O(n)，计数过程为 O(n)，比较过程外层循环次数固定为 100，里层循环一共也只会执行 n 次，O(100+n)，即O(n)</p><p>空间复杂度：O(1)，其中一个固定长度的计数数组与一个统计变量，与输入 N 的大小无关</p><p><strong>代码：</strong></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">heightChecker</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] heights)</span> </span>&#123;        <span class="hljs-comment">// 值的范围是1 &lt;= heights[i] &lt;= 100，因此需要1,2,3,...,99,100，共101个桶</span>        <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">101</span>];        <span class="hljs-comment">// 遍历数组heights，计算每个桶中有多少个元素，也就是数组heights中有多少个1，多少个2，。。。，多少个100</span>        <span class="hljs-comment">// 将这101个桶中的元素，一个一个桶地取出来，元素就是有序的</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> height: heights) &#123;            arr[height]++;        &#125;        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;            <span class="hljs-comment">// arr[i]，i就是桶中存放的元素的值，arr[i]是元素的个数</span>            <span class="hljs-comment">// arr[i]-- 就是每次取出一个，一直取到没有元素，成为空桶</span>            <span class="hljs-keyword">while</span> (arr[i]-- &gt; <span class="hljs-number">0</span> ) &#123;                <span class="hljs-comment">// 从桶中取出元素时，元素的排列顺序就是非递减的，然后与heights中的元素比较，如果不同，计算器就加1</span>                <span class="hljs-keyword">if</span> (heights[j++] != i)                    count++;            &#125;        &#125;        <span class="hljs-keyword">return</span> count;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>简单</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>零钱兑换</title>
    <link href="/2020/07/01/CoinChange/"/>
    <url>/2020/07/01/CoinChange/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p><p><strong>示例：</strong></p><pre><code class="hljs angelscript">输入: coins = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>], amount = <span class="hljs-number">11</span>输出: <span class="hljs-number">3</span> 解释: <span class="hljs-number">11</span> = <span class="hljs-number">5</span> + <span class="hljs-number">5</span> + <span class="hljs-number">1</span>输入: coins = [<span class="hljs-number">2</span>], amount = <span class="hljs-number">3</span>输出: <span class="hljs-number">-1</span></code></pre><p><strong>说明：</strong></p><p>你可以认为每种硬币的数量是无限的。</p><h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p>这道题如果用贪心，得到的不一定是最优解，用回溯，会超时，考虑用动态规划<br>动态规划的核心思想是。。把Question划归成Subquestion，再把Subquestion划归成Subsubquestion。。直到可以求解</p><p>对于这道题，以coins = [1, 2, 5], amount = 11为例<br>我们要求组成11的最少硬币数，可以考虑组合中的最后一个硬币分别是1，2，5的情况，比如</p><ul><li>最后一个硬币是1的话，最少硬币数应该为【组成10的最少硬币数】+ 1枚（1块硬币）</li><li>最后一个硬币是2的话，最少硬币数应该为【组成9的最少硬币数】+ 1枚（2块硬币）</li><li>最后一个硬币是5的话，最少硬币数应该为【组成6的最少硬币数】+ 1枚（5块硬币）</li></ul><p>在这3种情况中硬币数最少的那个就是结果<br>按同样的道理，我们也可以分别再求出组成10的最少硬币数，组成9的最少硬币数，组成6的最少硬币数。。。<br>发现了吗，这种当前状态的问题可以转化成之前状态问题的，一般就是动态规划的套路<br>所以我们自底向上依次求组成1，2…一直到11的最少硬币数<br>对每一个数，依次比较最后一个硬币是不同面额的情况，从中选出最小值</p><p><strong>关键点解析：</strong></p><p>用dp[i] 来表示组成i块钱，需要最少的硬币数，那么</p><ol><li>第j个硬币我可以选择不拿 这个时候， 硬币数 = dp[i]</li><li>第j个硬币我可以选择拿 这个时候， 硬币数 = dp[i - coins[j]] + 1</li><li>对于每一个 dp[i] 我们都选择遍历一遍 coin， 不断更新 dp[i]</li></ol><p>⚠️注意：这里有两个小技巧：</p><ul><li>预设一个0位方便后续计算，组成0的最少硬币数是0，所以dp[0] = 0</li><li>给每一个数预设一个最小值amount+1，因为硬币面额最小为整数1，所以只要有解，最小硬币数必然小于amount+1</li></ul><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] coins, <span class="hljs-keyword">int</span> amount)</span> </span>&#123;        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[amount+<span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;amount+<span class="hljs-number">1</span>; i++) &#123;            dp[i] = i == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : amount+<span class="hljs-number">1</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> coin : coins) &#123;                <span class="hljs-keyword">if</span>(i &gt;= coin) &#123;                    dp[i] = Math.min(dp[i-coin] + <span class="hljs-number">1</span>, dp[i]);                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[amount] == amount+<span class="hljs-number">1</span> ? -<span class="hljs-number">1</span> : dp[amount];    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>斐波那契数列</title>
    <link href="/2020/07/01/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"/>
    <url>/2020/07/01/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><p>写一个函数，输入 <code>n</code> ，求斐波那契（Fibonacci）数列的第 <code>n</code> 项。斐波那契数列的定义如下：</p><pre><code class="hljs angelscript">F(<span class="hljs-number">0</span>) = <span class="hljs-number">0</span>,   F(<span class="hljs-number">1</span>) = <span class="hljs-number">1</span>F(N) = F(N - <span class="hljs-number">1</span>) + F(N - <span class="hljs-number">2</span>), 其中 N &gt; <span class="hljs-number">1.</span></code></pre><p>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p><strong>示例：</strong></p><pre><code class="hljs angelscript">输入：n = <span class="hljs-number">2</span>输出：<span class="hljs-number">1</span>输入：n = <span class="hljs-number">5</span>输出：<span class="hljs-number">5</span></code></pre><p><strong>提示：</strong> 0 &lt;= n &lt;= 100</p><h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h2><p><strong>动态规划：</strong></p><ul><li><strong>原理：</strong> 以斐波那契数列性质 f(n+1) = f(n) + f(n−1) 为转移方程。</li><li>从计算效率、空间复杂度上看，动态规划是本题的最佳解法。</li></ul><p><strong>动态规划解析：</strong></p><ul><li><strong>状态定义：</strong> 设 dp 为一维数组，其中 dp[i] 的值代表斐波那契数列第 i 个数字 </li><li><strong>转移方程：</strong> dp[i+1] = dp[i] + dp[i−1]，即对应数列定义 f(n+1) = f(n) + f(n−1)；</li><li><strong>初始状态：</strong> dp[0]=0，dp[1]=1，即初始化前两个数字；</li><li><strong>返回值：</strong> dp[n] ，即斐波那契数列的第 n 个数字。</li></ul><p><strong>空间复杂度优化：</strong>若新建长度为 n 的 dp 列表，则空间复杂度为 O(N)。</p><ul><li>由于 dp 列表第 i 项只与第 i−1 和第 i−2 项有关，因此只需要初始化三个整形变量 <code>sum</code>, <code>a</code>, <code>b</code> ，利用辅助变量 sum 使 a,b 两数字交替前进即可 （具体实现见代码）。</li><li>节省了 dp 列表空间，因此空间复杂度降至 O(1)。</li></ul><p><strong>循环求余法：</strong></p><p>​    <strong>大数越界：</strong> 随着 n 增大, f(n) 会超过 <code>Int32</code> 甚至 <code>Int64</code> 的取值范围，导致最终的返回值错误。</p><ul><li><strong>求余运算规则：</strong> 设正整数 x , y , p ，求余符号为 % ，则有 ( x + y ) % p = ( x % p + y % p ) % p。</li><li><strong>解析：</strong> 根据以上规则，可推出 f(n) % p = [f(n−1) % p + f(n−2) % p] % p ，从而可以在循环过程中每次计算 sum=(a+b)⊙1000000007，此操作与最终返回前取余等价。</li></ul><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(N)： 计算 f(n) 需循环 n 次，每轮循环内计算操作使用 O(1) 。</li><li>空间复杂度 O(1)： 几个标志变量使用常数大小的额外空间。</li></ul><p><strong>图解：</strong></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggbe6w9pooj314k0mugls.jpg" srcset="/img/loading.gif" alt="img"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggbe7583axj314k0muq3k.jpg" srcset="/img/loading.gif" alt="img"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggbe7cbjqhj314k0mu74w.jpg" srcset="/img/loading.gif" alt="img"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggbe7igta5j314k0muaao.jpg" srcset="/img/loading.gif" alt="img"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggbe7ox1acj314k0mujs1.jpg" srcset="/img/loading.gif" alt="img"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggbe7vwm1kj314k0muwf4.jpg" srcset="/img/loading.gif" alt="img"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggbe82d3xcj314k0mut9c.jpg" srcset="/img/loading.gif" alt="img"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggbe890edgj314k0muwew.jpg" srcset="/img/loading.gif" alt="img"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggbe8f6y3wj314k0mudhl.jpg" srcset="/img/loading.gif" alt="img"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggbe8ksyvej314k0muwfa.jpg" srcset="/img/loading.gif" alt="img"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggbe8qwjf3j314k0mut9i.jpg" srcset="/img/loading.gif" alt="img"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggbe8wtqyoj314k0mut9k.jpg" srcset="/img/loading.gif" alt="img"></p><p><strong>代码：</strong></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">1</span>, sum;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;            sum = (a + b) % <span class="hljs-number">1000000007</span>;            a = b;            b = sum;        &#125;        <span class="hljs-keyword">return</span> a;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组和链表的优缺点</title>
    <link href="/2020/07/01/arrayandlinkedlist/"/>
    <url>/2020/07/01/arrayandlinkedlist/</url>
    
    <content type="html"><![CDATA[<p><strong>数组</strong></p><p>由于是紧凑连续存储,可以随机访问，通过索引快速找到对应元素，而且相对节约存储空间。但正因为连续存储，内存空间必须一次性分配够，所以说数组如果要扩容，需要重新分配一块更大的空间，再把数据全部复制过去，时间复杂度 O(N)；而且你如果想在数组中间进行插入和删除，每次必须搬移后面的所有数据以保持连续，时间复杂度 O(N)。</p><p><strong>链表</strong></p><p>因为元素不连续，而是靠指针指向下一个元素的位置，所以不存在数组的扩容问题；如果知道某一元素的前驱和后驱，操作指针即可删除该元素或者插入新元素，时间复杂度 O(1)。但是正因为存储空间不连续，你无法根据一个索引算出对应元素的地址，所以不能随机访问；而且由于每个元素必须存储指向前后元素位置的指针，会消耗相对更多的储存空间。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>88.合并两个有序数组</title>
    <link href="/2020/06/30/merge-sorted-array/"/>
    <url>/2020/06/30/merge-sorted-array/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你两个有序整数数组 nums1 和 nums2 ，请你将 nums2 合并到 nums1 中<em>，</em>使 nums1 成为一个有序数组。</p><p><strong>说明：</strong></p><ul><li>初始化 nums1 和 nums2 的元素数量分别为 m 和 n。</li><li>你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。</li></ul><p><strong>示例：</strong></p><pre><code class="hljs angelscript">输入:nums1 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>], m = <span class="hljs-number">3</span>nums2 = [<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>],       n = <span class="hljs-number">3</span>输出: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]</code></pre><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li>标签：从后向前数组遍历</li><li>因为 <code>nums1</code> 的空间都集中在后面，所以从后向前处理排序的数据会更好，节省空间，一边遍历一边将值填充进去</li><li>设置指针 len1 和 len2 分别指向 nums1 和 nums2 的有数字尾部，从尾部值开始比较遍历，同时设置指针 len 指向 nums1 的最末尾，每次遍历比较值大小之后，则进行填充</li><li>当 <code>len1&lt;0</code> 时遍历结束，此时 <code>nums2</code> 中还有数据未拷贝完全，将其直接拷贝到 <code>nums1</code> 的前面，最后得到结果数组</li><li>时间复杂度：O(m+n)</li></ul><p><strong>图解：</strong></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggdioekagwj30le0a2q3j.jpg" srcset="/img/loading.gif" alt="img"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggdiomxx6sj30le0a2752.jpg" srcset="/img/loading.gif" alt="img"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggdiow9ypfj30le0a2gmj.jpg" srcset="/img/loading.gif" alt="img"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggdip2chr0j30le0a2jsi.jpg" srcset="/img/loading.gif" alt="img"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggdip7y4dbj30le0a2ta0.jpg" srcset="/img/loading.gif" alt="img"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggdipd4obdj30le0a2dha.jpg" srcset="/img/loading.gif" alt="img"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span>[] nums2, <span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">int</span> len1 = m - <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> len2 = n - <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> len = m + n - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(len1 &gt;= <span class="hljs-number">0</span> &amp;&amp; len2 &gt;= <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">// 注意--符号在后面，表示先进行计算再减1，这种缩写缩短了代码</span>            nums1[len--] = nums1[len1] &gt; nums2[len2] ? nums1[len1--] : nums2[len2--];        &#125;        <span class="hljs-comment">// 表示将nums2数组从下标0位置开始，拷贝到nums1数组中，从下标0位置开始，长度为len2+1</span>        System.arraycopy(nums2, <span class="hljs-number">0</span>, nums1, <span class="hljs-number">0</span>, len2 + <span class="hljs-number">1</span>);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>双指针</tag>
      
      <tag>简单</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>隐秘的角落让我印象深刻的镜头</title>
    <link href="/2020/06/29/thebadkids/"/>
    <url>/2020/06/29/thebadkids/</url>
    
    <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg9g4gei65j31hc0u014d.jpg" srcset="/img/loading.gif" alt="p2611236839"></p><p>最明亮清新的画面，最暗潮汹涌的同框。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg9eg5ca8oj31hc0u0npf.jpg" srcset="/img/loading.gif" alt="p2609494086.jpg"></p><p>这是全剧唯一一个能让人看到他们身上依然保有童真的镜头。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg9g5o71b4j311y0lbn6d.jpg" srcset="/img/loading.gif" alt="p2609823056.jpg"></p><p>甜腻又恶心。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg9g62u474j31hc0swtjg.jpg" srcset="/img/loading.gif" alt="p2610642764"></p><p>另一种授课，黑化的开始。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg9g7hjoqzj31hc0sw77f.jpg" srcset="/img/loading.gif" alt="p2611410903"></p><p>以爱之名行恶，最终失去所爱。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg9g805k66j31hc0swn4z.jpg" srcset="/img/loading.gif" alt="p2611413427"></p><p>朝阳，东升。</p>]]></content>
    
    
    <categories>
      
      <category>movies</category>
      
    </categories>
    
    
    <tags>
      
      <tag>国产剧</tag>
      
      <tag>好剧</tag>
      
      <tag>隐秘的角落</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>稀疏数组</title>
    <link href="/2020/06/29/SparseArray/"/>
    <url>/2020/06/29/SparseArray/</url>
    
    <content type="html"><![CDATA[<h2 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h3><p>​    稀疏数组可以看做是普通数组的压缩，但是这里说的普通数组是值无效数据量远大于有效数据量的数组</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg8uuowb2jj30se0is41t.jpg" srcset="/img/loading.gif" alt="img"></p><h3 id="2-存储"><a href="#2-存储" class="headerlink" title="2. 存储"></a>2. 存储</h3><p>​    刚说到稀疏数组是一种压缩后的数组，为什么要进行压缩存储呢？</p><ul><li>原数组中存在大量的无效数据，占据了大量的存储空间，真正有用的数据却少之又少</li><li>压缩存储可以节省存储空间以避免资源的不必要的浪费，在数据序列化到磁盘时，压缩存储可以提高IO效率</li></ul><h3 id="3-存储方式"><a href="#3-存储方式" class="headerlink" title="3. 存储方式"></a>3. 存储方式</h3><p>​         第一行存储原始数据总行数，总列数，总的非0数据个数</p><p>​         接下来每一行都存储非0数所在行，所在列，和具体值</p><h3 id="4-代码实现"><a href="#4-代码实现" class="headerlink" title="4. 代码实现"></a>4. 代码实现</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SparseArray</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * &lt;p&gt;</span><span class="hljs-comment">     *     稀疏数组可以简单的看作为是压缩，在开发中也会使用到。比如将数据序列化到磁盘上，减少数据量，在IO过程中提高效率等等。</span><span class="hljs-comment">     *</span><span class="hljs-comment">     *     &lt;p&gt;</span><span class="hljs-comment">     *         为什么要进行压缩？</span><span class="hljs-comment">     *              - 由于稀疏矩阵中存在大量的“空”值，占据了大量的存储空间，而真正有用的数据却少之又少，</span><span class="hljs-comment">     *              - 且在计算时浪费资源，所以要进行压缩存储以节省存储空间和计算方便。</span><span class="hljs-comment">     *     &lt;/p&gt;</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * &lt;/p&gt;</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> args</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 初始化二维数组</span><span class="hljs-comment">         * &lt;p&gt;</span><span class="hljs-comment">         *     0 0 0 0 0 0 0 0 0 0 0</span><span class="hljs-comment">         *     0 0 1 0 0 0 0 0 0 0 0</span><span class="hljs-comment">         *     0 0 0 0 2 0 0 0 0 0 0</span><span class="hljs-comment">         *     0 0 0 0 0 0 0 0 0 0 0</span><span class="hljs-comment">         *     0 0 0 0 0 0 0 0 0 0 0</span><span class="hljs-comment">         *     0 0 0 0 0 0 0 0 0 0 0</span><span class="hljs-comment">         *     0 0 0 0 0 0 0 0 0 0 0</span><span class="hljs-comment">         *     0 0 0 0 0 0 0 0 0 0 0</span><span class="hljs-comment">         *     0 0 0 0 0 0 0 0 0 0 0</span><span class="hljs-comment">         *     0 0 0 0 0 0 0 0 0 0 0</span><span class="hljs-comment">         *     0 0 0 0 0 0 0 0 0 0 0</span><span class="hljs-comment">         * &lt;/p&gt;</span><span class="hljs-comment">         */</span>        <span class="hljs-comment">//初始化原数组</span>        <span class="hljs-keyword">int</span>[][] array = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">11</span>][<span class="hljs-number">11</span>];        array[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;        array[<span class="hljs-number">2</span>][<span class="hljs-number">4</span>] = <span class="hljs-number">2</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>[] row : array)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> item : row)&#123;                System.out.printf(<span class="hljs-string">"%d\t"</span>,item);            &#125;        &#125;        System.out.println(<span class="hljs-string">"---------&gt; 二维数组转稀疏数组"</span>);        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 稀疏数组</span><span class="hljs-comment">         * &lt;p&gt;</span><span class="hljs-comment">         *     11 11 2</span><span class="hljs-comment">         *     1  2  1</span><span class="hljs-comment">         *     2  4  2</span><span class="hljs-comment">         * &lt;/p&gt;</span><span class="hljs-comment">         */</span>        <span class="hljs-comment">//得到非0数据数</span>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;<span class="hljs-number">11</span>;i++)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j&lt;<span class="hljs-number">11</span>;j++)&#123;                <span class="hljs-keyword">if</span>(array[i][j] != <span class="hljs-number">0</span>)&#123;                    sum++;                &#125;            &#125;        &#125;        <span class="hljs-comment">//创建稀疏数组</span>        <span class="hljs-keyword">int</span>[][] sparseArray = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[sum+<span class="hljs-number">1</span>][<span class="hljs-number">3</span>];        <span class="hljs-comment">//给稀疏数组赋值</span>        sparseArray[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">11</span>;        sparseArray[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">11</span>;        sparseArray[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] = sum;        <span class="hljs-comment">//将非0的数放入稀疏数组</span>        <span class="hljs-comment">//count：标识第几个非0数</span>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;<span class="hljs-number">11</span>;i++)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j&lt;<span class="hljs-number">11</span>;j++)&#123;                <span class="hljs-keyword">if</span>(array[i][j] != <span class="hljs-number">0</span>)&#123;                    count++;                    sparseArray[count][<span class="hljs-number">0</span>] = i;                    sparseArray[count][<span class="hljs-number">1</span>] = j;                    sparseArray[count][<span class="hljs-number">2</span>] = array[i][j];                &#125;            &#125;        &#125;        <span class="hljs-comment">//遍历稀疏数组</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;sparseArray.length;i++)&#123;            System.out.printf(<span class="hljs-string">"%d%d%d\t"</span>,sparseArray[i][<span class="hljs-number">0</span>],sparseArray[i][<span class="hljs-number">1</span>],sparseArray[i][<span class="hljs-number">2</span>]);        &#125;        System.out.println(<span class="hljs-string">"-----------&gt;稀疏数组转回原始数组"</span>);        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 恢复的二维数组</span><span class="hljs-comment">         * &lt;p&gt;</span><span class="hljs-comment">         *     0 0 0 0 0 0 0 0 0 0 0</span><span class="hljs-comment">         *     0 0 1 0 0 0 0 0 0 0 0</span><span class="hljs-comment">         *     0 0 0 0 2 0 0 0 0 0 0</span><span class="hljs-comment">         *     0 0 0 0 0 0 0 0 0 0 0</span><span class="hljs-comment">         *     0 0 0 0 0 0 0 0 0 0 0</span><span class="hljs-comment">         *     0 0 0 0 0 0 0 0 0 0 0</span><span class="hljs-comment">         *     0 0 0 0 0 0 0 0 0 0 0</span><span class="hljs-comment">         *     0 0 0 0 0 0 0 0 0 0 0</span><span class="hljs-comment">         *     0 0 0 0 0 0 0 0 0 0 0</span><span class="hljs-comment">         *     0 0 0 0 0 0 0 0 0 0 0</span><span class="hljs-comment">         *     0 0 0 0 0 0 0 0 0 0 0</span><span class="hljs-comment">         * &lt;/p&gt;</span><span class="hljs-comment">         */</span>        <span class="hljs-keyword">int</span>[][] oldArray = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[sparseArray[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]][sparseArray[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]];        <span class="hljs-comment">//将原来非0的数填充回去</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i&lt;=count;i++)&#123;          oldArray[sparseArray[i][<span class="hljs-number">0</span>]][sparseArray[i][<span class="hljs-number">1</span>]] = sparseArray[i][<span class="hljs-number">2</span>];        &#125;        <span class="hljs-comment">//遍历刚转回的原始数组</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>[] row : oldArray)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> item : row)&#123;                System.out.printf(<span class="hljs-string">"%d\t"</span>,item);            &#125;        &#125;    &#125;&#125;</code></pre><h3 id="将稀疏存储到磁盘中"><a href="#将稀疏存储到磁盘中" class="headerlink" title="将稀疏存储到磁盘中"></a>将稀疏存储到磁盘中</h3><p>我们可以使用java的IO流将稀疏数组存放到磁盘中，原数组和稀疏数组比较，肯定是稀疏数组体积更小，占用空间更小</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 将稀疏数组存入磁盘（文件）</span><span class="hljs-comment"> *</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sparseArrayToIo</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] sparseArray)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;  File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">"sparseArray.txt"</span>);  <span class="hljs-keyword">if</span>(!file.exists())&#123;    file.createNewFile();  &#125;  FileWriter writer = <span class="hljs-keyword">new</span> FileWriter(file);  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>; i &lt; sparseArray.length; i++) &#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++) &#123;      writer.write(sparseArray[i][j]);    &#125;  &#125;  writer.flush();  writer.close();&#125;</code></pre><h3 id="从磁盘中读取稀疏数组"><a href="#从磁盘中读取稀疏数组" class="headerlink" title="从磁盘中读取稀疏数组"></a>从磁盘中读取稀疏数组</h3><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 读文件获取稀疏数组</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[][] sparseArrayFromIo() <span class="hljs-keyword">throws</span> Exception &#123;  Map&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap();  <span class="hljs-keyword">int</span> count=<span class="hljs-number">0</span>; <span class="hljs-keyword">int</span> data = <span class="hljs-number">0</span>;  <span class="hljs-keyword">while</span> ((data=reader.read())!=-<span class="hljs-number">1</span>)&#123;    map.put(count,data); count++;  &#125;  <span class="hljs-keyword">if</span> (map.size() == <span class="hljs-number">0</span>)&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;  &#125;  <span class="hljs-keyword">int</span>[][] sparseArray = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[map.size()/<span class="hljs-number">3</span>][<span class="hljs-number">3</span>];  <span class="hljs-keyword">int</span> index =<span class="hljs-number">0</span>;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; map.size()/<span class="hljs-number">3</span>; i++) &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++) &#123;      sparseArray[i][j] = map.get(index);      index ++;    &#125;  &#125;  map.clear();  <span class="hljs-keyword">return</span> sparseArray;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回文数</title>
    <link href="/2020/06/28/palindrome-number/"/>
    <url>/2020/06/28/palindrome-number/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p><p><strong>示例：</strong></p><pre><code class="hljs yaml"><span class="hljs-string">输入:</span> <span class="hljs-number">121</span><span class="hljs-string">输出:</span> <span class="hljs-literal">true</span><span class="hljs-string">输入:</span> <span class="hljs-number">-121</span><span class="hljs-string">输出:</span> <span class="hljs-literal">false</span><span class="hljs-string">解释:</span> <span class="hljs-string">从左向右读,</span> <span class="hljs-string">为</span> <span class="hljs-number">-121</span> <span class="hljs-string">。</span> <span class="hljs-string">从右向左读,</span> <span class="hljs-string">为</span> <span class="hljs-number">121</span><span class="hljs-bullet">-</span> <span class="hljs-string">。因此它不是一个回文数。</span><span class="hljs-string">输入:</span> <span class="hljs-number">10</span><span class="hljs-string">输出:</span> <span class="hljs-literal">false</span><span class="hljs-string">解释:</span> <span class="hljs-string">从右向左读,</span> <span class="hljs-string">为</span> <span class="hljs-number">01</span> <span class="hljs-string">。因此它不是一个回文数。</span></code></pre><p><strong>进阶：</strong></p><p>你能不将整数转为字符串来解决这个问题吗？</p><p><strong>解题思路：</strong></p><p>直观上来看待回文数的话，就感觉像是将数字进行对折后看能否一一对应。</p><p>所以这个解法的操作就是 <strong>取出后半段数字进行翻转</strong>。</p><p>这里需要注意的一个点就是由于回文数的位数可奇可偶，所以当它的长度是偶数时，它对折过来应该是相等的；当它的长度是奇数时，那么它对折过来后，有一个的长度需要去掉一位数（除以 10 并取整）。</p><p>具体做法如下：</p><ul><li>每次进行取余操作 （ %10），取出最低的数字：<code>y = x % 10</code></li><li>将最低的数字加到取出数的末尾：<code>revertNum = revertNum * 10 + y</code></li><li>每取一个最低位数字，x 都要自除以 10</li><li>判断 <code>x</code> 是不是小于 <code>revertNum</code> ，当它小于的时候，说明数字已经对半或者过半了</li><li>最后，判断奇偶数情况：如果是偶数的话，revertNum 和 x 相等；如果是奇数的话，最中间的数字就在revertNum 的最低位上，将它除以 10 以后应该和 x 相等。</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg89t68nt2j31800u0wku.jpg" srcset="/img/loading.gif" alt="img"></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;        <span class="hljs-comment">//思考：这里大家可以思考一下，为什么末尾为 0 就可以直接返回 false</span>        <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || (x % <span class="hljs-number">10</span> == <span class="hljs-number">0</span> &amp;&amp; x != <span class="hljs-number">0</span>)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">int</span> revertedNumber = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (x &gt; revertedNumber) &#123;            revertedNumber = revertedNumber * <span class="hljs-number">10</span> + x % <span class="hljs-number">10</span>;            x /= <span class="hljs-number">10</span>;        &#125;        <span class="hljs-keyword">return</span> x == revertedNumber || x == revertedNumber / <span class="hljs-number">10</span>;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>整数反转</title>
    <link href="/2020/06/28/reverse-integer/"/>
    <url>/2020/06/28/reverse-integer/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p><p><strong>示例：</strong></p><pre><code class="hljs angelscript">输入: <span class="hljs-number">123</span>输出: <span class="hljs-number">321</span>输入: <span class="hljs-number">-123</span>输出: <span class="hljs-number">-321</span>输入: <span class="hljs-number">120</span>输出: <span class="hljs-number">21</span></code></pre><p><strong>注意：</strong></p><p>假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [-2147483647, 2147483647]。请根据这个假设，如果反转后整数溢出那么就返回 0。</p><p><strong>解题思路：</strong></p><p>依次取出当前数字的最后一位数，累加。<br>关键在于如何判断整数溢出：将每次操作后的数字用临时变量存储，对该变量“反操作”，若与操作前的结果不等，则发生溢出，直接返回0</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span> ;        <span class="hljs-keyword">while</span>(x != <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">int</span> temp = x % <span class="hljs-number">10</span> + res * <span class="hljs-number">10</span>;            <span class="hljs-keyword">if</span>((temp - x % <span class="hljs-number">10</span>) / <span class="hljs-number">10</span> != res)&#123; <span class="hljs-comment">//最关键的一步</span>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> ;            &#125;            res = temp ;            x /= <span class="hljs-number">10</span> ;        &#125;        <span class="hljs-keyword">return</span> res ;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>验证回文字符串 Ⅱ</title>
    <link href="/2020/06/28/valid-palindrome-ii/"/>
    <url>/2020/06/28/valid-palindrome-ii/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong><br>给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。</p><p><strong>示例：</strong><br>输入: “aba”<br>输出: True</p><p>输入: “abca”<br>输出: True<br>解释: 你可以删除c字符。</p><p><strong>解题思路：</strong><br>使用双指针可以很容易判断一个字符串是否是回文字符串：令一个指针从左到右遍历，一个指针从右到左遍历，这两个指针同时移动一个位置，每次都判断两个指针指向的字符是否相同，如果都相同，字符串才是具有左右对称性质的回文字符串。<br>                                     <img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg890ifl4qg309v08rglm.gif" srcset="/img/loading.gif" alt=""><br>本题的关键是处理删除一个字符。在使用双指针遍历字符串时，如果出现两个指针指向的字符不相等的情况，我们就试着删除一个字符，再判断删除完之后的字符串是否是回文字符串。<br>在判断是否为回文字符串时，我们不需要判断整个字符串，因为左指针左边和右指针右边的字符之前已经判断过具有对称性质，所以只需要判断中间的子字符串即可。<br>在试着删除字符时，我们既可以删除左指针指向的字符，也可以删除右指针指向的字符。<br>                                <img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg890hr41tg30ce08dt8y.gif" srcset="/img/loading.gif" alt=""></p><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">validPalindrome</span><span class="hljs-params">(String s)</span> </span>&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = s.length() - <span class="hljs-number">1</span>; i &lt; j; i++, j--) &#123;            <span class="hljs-keyword">if</span>(s.charAt(i) != s.charAt(j)) &#123;                <span class="hljs-keyword">return</span> isPalindrome(s, i + <span class="hljs-number">1</span>, j) || isPalindrome(s, i, j - <span class="hljs-number">1</span>);            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;        <span class="hljs-keyword">while</span>(i &lt; j) &#123;            <span class="hljs-keyword">if</span>(s.charAt(i++) != s.charAt(j--)) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>反转字符串中的元音字母</title>
    <link href="/2020/06/28/reverse-vowels-of-a-string/"/>
    <url>/2020/06/28/reverse-vowels-of-a-string/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong><br>编写一个函数，以字符串作为输入，反转该字符串中的元音字母。</p><p><strong>示例：</strong><br>输入: “hello”<br>输出: “holle”</p><p>输入: “leetcode”<br>输出: “leotcede”</p><p><strong>解题思路：</strong><br>使用双指针，一个指针从头向尾遍历，一个指针从尾到头遍历，当两个指针都遍历到元音字符时，交换这两个元音字符。<br>为了快速判断一个字符是不是元音字符，我们将全部元音字符添加到集合 HashSet 中，从而以 O(1) 的时间复杂度进行该操作。</p><ul><li>时间复杂度为 O(N)：只需要遍历所有元素一次</li><li>空间复杂度 O(1)：只需要使用两个额外变量</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg88we5abcg30jc0btaan.gif" srcset="/img/loading.gif" alt=""></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> HashSet&lt;Character&gt; vowels =  <span class="hljs-keyword">new</span> HashSet&lt;&gt;(        Arrays.asList(<span class="hljs-string">'a'</span>, <span class="hljs-string">'e'</span>, <span class="hljs-string">'i'</span>, <span class="hljs-string">'o'</span>, <span class="hljs-string">'u'</span>, <span class="hljs-string">'A'</span>, <span class="hljs-string">'E'</span>, <span class="hljs-string">'I'</span>, <span class="hljs-string">'O'</span>, <span class="hljs-string">'U'</span>));    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">reverseVowels</span><span class="hljs-params">(String s)</span> </span>&#123;        <span class="hljs-keyword">if</span>(s == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = s.length() - <span class="hljs-number">1</span>;        <span class="hljs-keyword">char</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[s.length()];        <span class="hljs-keyword">while</span>(i &lt;= j) &#123;            <span class="hljs-keyword">char</span> ci = s.charAt(i);            <span class="hljs-keyword">char</span> cj = s.charAt(j);            <span class="hljs-keyword">if</span>(!vowels.contains(ci)) &#123;                result[i++] = ci;            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!vowels.contains(cj)) &#123;                result[j--] = cj;            &#125;<span class="hljs-keyword">else</span> &#123;                result[i++] = cj;                result[j--] = ci;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(result);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>平方数之和</title>
    <link href="/2020/06/28/sum-of-square-numbers/"/>
    <url>/2020/06/28/sum-of-square-numbers/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong><br>给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a&sup2; + b&sup2; = c。</p><p><strong>示例：</strong></p><pre><code class="hljs yaml"><span class="hljs-string">输入:</span> <span class="hljs-number">5</span><span class="hljs-string">输出:</span> <span class="hljs-literal">True</span><span class="hljs-string">解释:</span> <span class="hljs-number">1</span> <span class="hljs-string">*</span> <span class="hljs-number">1</span> <span class="hljs-string">+</span> <span class="hljs-number">2</span> <span class="hljs-string">*</span> <span class="hljs-number">2</span> <span class="hljs-string">=</span> <span class="hljs-number">5</span></code></pre><pre><code class="hljs yaml"><span class="hljs-string">输入:</span> <span class="hljs-number">3</span><span class="hljs-string">输出:</span> <span class="hljs-literal">False</span></code></pre><p><strong>解题思路：</strong><br>可以看成是在元素为 0 ~ target 的有序数组中查找两个数，使得这两个数的平方和为 target，如果能找到，则返回 true，表示 target 是两个整数的平方和。<br>本题和 167. Two Sum II - Input array is sorted 类似，只有一个明显区别：一个是和为 target，一个是平方和为 target。本题同样可以使用双指针得到两个数，使其平方和为 target。<br>本题的关键是右指针的初始化，实现剪枝，从而降低时间复杂度。设右指针为 x，左指针固定为 0，为了使 0&sup2; + x&sup2; 的值尽可能接近 target，我们可以将 x 取为 sqrt(target)。<br>因为最多只需要遍历一次 0 ~ sqrt(target)，所以时间复杂度为 O(sqrt(target))。又因为只使用了两个额外的变量，因此空间复杂度为 O(1)。</p><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">judgeSquareSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> target)</span> </span>&#123;        <span class="hljs-keyword">if</span>(target &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = (<span class="hljs-keyword">int</span>)Math.sqrt(target);        <span class="hljs-keyword">while</span>(i &lt;= j) &#123;            <span class="hljs-keyword">int</span> sum = i * i + j * j;            <span class="hljs-keyword">if</span>(sum == target) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum &gt; target) &#123;                j--;            &#125;<span class="hljs-keyword">else</span> &#123;                i++;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>两数之和</title>
    <link href="/2020/06/28/twosum/"/>
    <url>/2020/06/28/twosum/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong><br>    给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。<br>    你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。<br><strong>示例：</strong><br>    给定 nums = [2, 7, 11, 15], target = 9<br>    因为 nums[0] + nums[1] = 2 + 7 = 9<br>    所以返回 [0, 1]<br><strong>解题思路：</strong></p><ul><li><p>标签：哈希映射</p></li><li><p>这道题本身如果通过暴力遍历的话也是很容易解决的，时间复杂度在 O(n2)</p></li><li><p>由于哈希查找的时间复杂度为 O(1)，所以可以利用哈希容器 map 降低时间复杂度</p></li><li><p>遍历数组 nums，i 为当前下标，每个值都判断map中是否存在 target-nums[i] 的 key 值</p></li><li><p>如果存在则找到了两个值，如果不存在则将当前的 (nums[i],i) 存入 map 中，继续遍历直到找到为止</p></li><li><p>如果最终都没有结果则抛出异常</p></li><li><p>时间复杂度：O(n)</p></li></ul><p>  <strong>图解：</strong></p><p>  <img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg87mvg7buj30yo0k2758.jpg" srcset="/img/loading.gif" alt="1"></p><p>  <img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg87n0zbh3j30yo0k2q4a.jpg" srcset="/img/loading.gif" alt="2"></p><p>  <img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg87n55x68j30yo0k2abf.jpg" srcset="/img/loading.gif" alt="3"></p><p>  <img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg87nd6l3bj30yo0k2tab.jpg" srcset="/img/loading.gif" alt="4"></p><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] twoSum(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt; nums.length; i++) &#123;            <span class="hljs-keyword">int</span> complement = target - nums[i];            <span class="hljs-keyword">if</span>(map.containsKey(complement)) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123;map.get(complement),i&#125;;            &#125;            map.put(nums[i], i);        &#125;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"No two sum solution"</span>);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
